<!DOCTYPE html> <html lang=en > <meta charset=utf-8  /> <meta http-equiv=X-UA-Compatible  content="IE=edge,chrome=1" /> <meta name=viewport  content="width=device-width, initial-scale=1.0" /> <title> IntSet Development - Blog - athanclark.com </title> <meta name=description  content="On 2023-11-21, I developed a set container for JavaScript <code>bigint</code>s. This allows for unions, intersections, and other set operations, but in a relatively fast manner. This blog post describes my development methodology, the issues I faced, and how I overcame them." /> <meta name=author  content="Athan Clark" /> <meta name=keywords  content="IntSet, JavaScript, Bit Masking" /> <script defer src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script> <script defer src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script> <script defer src="./intset/plot_bench.js"></script> <link rel=stylesheet  type="text/css" href=/main-26105c4c0ec.min.css  /> <script> window.onload = function() { const mobileNav = document.getElementById('page-select'); const currentPage = mobileNav.parentElement.parentElement.classList[0]; for (const navItem of mobileNav.children) { if (navItem.className === currentPage) { navItem.setAttribute('selected',''); } } mobileNav.onchange = function(e) { window.location.pathname = `/${e.target.value}.html`; }; }; </script> <main class=container > <header> <h1>athanclark.com</h1> </header> <section class=grid > <nav class=" blog "> <ul> <li class=index > <a href="/index.html">Home</a> <li class=contact > <a href="/contact.html">Contact</a> <li class=portfolio > <a href="/portfolio.html">Portfolio</a> <li class=blog > <a href="/blog.html">Blog</a> </ul> <p><select id=page-select > <option class=index  value=index >Home <option class=contact  value=contact >Contact <option class=portfolio  value=portfolio >Portfolio <option class=blog  value=blog >Blog </select></p> </nav> <article> <h1>IntSet Development</h1> <dl> <dt> Written by: <dd> Athan Clark <dt> Date: <dd> <time datetime=2023-11-23 >2023-11-23</time> <dt> Keywords: <dd> IntSet, JavaScript, Bit Masking </dl> <hr /> <div> <h3>Abstract</h3> On 2023-11-21, I developed a set container for JavaScript <code>bigint</code>s. This allows for unions, intersections, and other set operations, but in a relatively fast manner. This blog post describes my development methodology, the issues I faced, and how I overcame them. </div> <h2>Table of Contents</h2> <div role=navigation  aria-label="Table of Contents"> <ul> <li><a href="#bit-masking" id=toc-bit-masking >Bit Masking</a> <ul> <li><a href="#bitwise-or-and-union" id=toc-bitwise-or-and-union >Bitwise Or and Union</a> <li><a href="#what-does-this-imply" id=toc-what-does-this-imply >What does this imply?</a> </ul> <li><a href="#unbounded-data" id=toc-unbounded-data >Unbounded Data</a> <ul> <li><a href="#a-first-stab-arrays" id=toc-a-first-stab-arrays >A first stab – Arrays</a> <ul> <li><a href="#issues-with-arrays" id=toc-issues-with-arrays >Issues with Arrays</a> </ul> <li><a href="#a-better-stab-maps" id=toc-a-better-stab-maps >A better stab – Maps</a> </ul> <li><a href="#implementation" id=toc-implementation >Implementation</a> <ul> <li><a href="#tests" id=toc-tests >Tests</a> <li><a href="#benchmarks" id=toc-benchmarks >Benchmarks</a> <ul> <li><a href="#interpretations" id=toc-interpretations >Interpretations</a> <li><a href="#further-interpretations" id=toc-further-interpretations >Further Interpretations</a> </ul> </ul> <li><a href="#conclusion" id=toc-conclusion >Conclusion</a> <ul> <li><a href="#considerations" id=toc-considerations >Considerations</a> </ul> </ul> </div> <hr /> <p><a href="#conclusion">tl;dr</a>, Don’t use more than 16k values with a variance greater than 65k.</p> <p>The purpose of IntSet is to act as a container for <code>bigint</code>s by utilizing bit masks and bitwise operators. This would increate the runtime performance and reduce memory use, assuming the contents of the sets are relatively close to one another.</p> <p>This blog post is an account of my development experience for this library, and a slight technical interlude on how it works. Before I go any further, I’d like to describe the bit masking and how it works.</p> <h1 id=bit-masking >Bit Masking</h1> <p>Assume you have some positive integer (natural number) <span class="math inline"><em>x</em> : ℕ</span>. Also assume you have some space of bits <span class="math inline"><em>n</em> : ℕ</span> long (for instance, a 32-bit integer takes up 32 bits, and therefore has 32 bits of space).</p> <p>If <span class="math inline"><em>x</em> &lt; <em>n</em></span>, then <span class="math inline"><em>x</em></span> can be represented as a single bit flipped in the space provided by <span class="math inline"><em>n</em></span> - <span class="math inline">0</span> is the first bit, <span class="math inline">1</span> is the second bit, <span class="math inline">2</span> is the third bit, and so on. If you were to turn the bit space in <span class="math inline"><em>n</em></span> into a (big-endian) integer <span class="math inline"><em>m</em></span>, and if <span class="math inline"><em>x</em></span>’s bit were the only bit flipped in the bit space of <span class="math inline"><em>n</em></span>, then <span class="math inline"><em>m</em> = 2<sup><em>x</em></sup></span>.</p> <p>As an example, let’s say <span class="math inline"><em>x</em> = 0</span>, and <span class="math inline"><em>n</em> = 8</span>. In this case, the first bit in <span class="math inline"><em>n</em></span> is <span class="math inline">1</span>, and the rest are <span class="math inline">0</span>. If we turn this bit space into a integer <span class="math inline"><em>m</em></span>, then it would equal <span class="math inline">1</span> – specifically, <span class="math inline">2<sup>0</sup> = 1</span>. You can try this in JavaScript – the bit space would look like <code>0b00000001</code>, and simply evaluating it reveals the value <code>1</code>.</p> <p>Or, let’s say that <span class="math inline"><em>x</em> = 7</span>, and <span class="math inline"><em>n</em> = 8</span> again. In that instance, <span class="math inline"><em>n</em></span>’s 8th bit is <span class="math inline">1</span>, and the rest are <span class="math inline">0</span>’s - it would look like <code>0b10000000</code> in JavaScript. If we were to evaluate this, it would return <code>128</code>, which is the same as <span class="math inline">2<sup>7</sup> = 128</span>.</p> <h2 id=bitwise-or-and-union >Bitwise Or and Union</h2> <p>Now lets imagine the union of these two examples – we’ll “zip” the bit spaces together, and if either of the bit spaces has a <span class="math inline">1</span>, we’ll retain it. Doing this would return <code>0b10000001</code> - <code>129</code> if evaluated. However, what we mean by this bit space is “both the values of <span class="math inline">0</span> and <span class="math inline">7</span> are present in the bitspace <span class="math inline">8</span>”.</p> <p>Fortunately, JavaScript allows for such operations through the bitwise operator <code>|</code>. If we try running <code>128 | 1</code>, we’ll receive the result <code>129</code>.</p> <h2 id=what-does-this-imply >What does this imply?</h2> <p>Given a contiguous bitspace size <span class="math inline"><em>n</em> : ℕ</span>, all natural numbers less than the bitspace size <span class="math inline">∀<em>x</em> : ℕ &lt; <em>n</em></span> can be represented in the bitspace via the presence of its <span class="math inline"><em>x</em></span>th bit. Furthermore, given a set of natural numbers less than the bitspace size, where each member of the set is referred to as <span class="math inline"><em>x</em><sub>1</sub>…<em>x</em><sub><em>q</em></sub></span>, the bitspace can be represented as:</p> <p><span class="math display"><em>m</em> = 2<sup><em>x</em><sub>1</sub></sup> ∪ 2<sup><em>x</em><sub>2</sub></sup> ∪ … ∪ 2<sup><em>x</em><sub><em>q</em></sub></sup></span></p> <p>Where <span class="math inline"><em>m</em></span> is the whole integer that represents the set, and $is the bitwise or operator <code>|</code>. These implications are expanded on the other operators as well:</p> <table> <thead> <tr class=header > <th style="text-align: center;">Bitwise Operator <th style="text-align: center;">Set Operator <tr class=odd > <td style="text-align: center;"><code>|</code> / OR <td style="text-align: center;"><span class="math inline">∪</span> / Union <tr class=even > <td style="text-align: center;"><code>&amp;</code> / AND <td style="text-align: center;"><span class="math inline">∩</span> / Intersection <tr class=odd > <td style="text-align: center;"><code>^</code> / XOR <td style="text-align: center;"><span class="math inline">⊕</span> / Symmetric Difference </table> <p>With these primitive operations, the difference operation can be defined as follows:</p> <p><span class="math display"><em>X</em> ∖ <em>Y</em> = <em>X</em> ∪ (<em>X</em>⊕<em>Y</em>)</span></p> <h1 id=unbounded-data >Unbounded Data</h1> <p>Now that we have a mechanism to create sets of natural numbers up to size <span class="math inline"><em>n</em> : ℕ</span>, we need one that could be (mostly) unbounded.</p> <h2 id=a-first-stab-arrays >A first stab – Arrays</h2> <p>Initially, I imagined am array of <span class="math inline"><em>m</em></span>’s to be the most intuitive solution – the value of any value <span class="math inline"><em>y</em> : ℕ</span> in an array of <span class="math inline"><em>p</em></span> elements, each of which holds an <span class="math inline"><em>m</em></span> with bit size <span class="math inline"><em>n</em></span> would be:</p> <p><span class="math display"><em>y</em> = <em>x</em><sub><em>q</em></sub> + (<em>i</em><sub><em>p</em></sub>×<em>n</em>)</span></p> <p>Where <span class="math inline"><em>i</em><sub><em>p</em></sub></span> is the (zero-based) index in the array – with a maximum value of <span class="math inline"><em>p</em></span>.</p> <p>Implementations of setwise union, intersection, and the like would be performed through <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Prelude.html#v:zipWith">zip-with</a> – where in the case of union and symmetric difference, the elements not present in the other set are retained as-is.</p> <h3 id=issues-with-arrays >Issues with Arrays</h3> <p>The critical issue with this solution is the case where the set only holds large values. In that circumstance, there will be a number of <span class="math inline">0</span>-valued <span class="math inline"><em>m</em></span> elements, up until the relevant <span class="math inline"><em>i</em><sub><em>p</em></sub></span> value – essentially, this makes the size of the set linear with respect to the maximum value of <span class="math inline"><em>y</em>/<em>n</em></span>, and likewise the setwise uperations would be <span class="math inline"><em>O</em>(<em>p</em>)</span>.</p> <p>This is unacceptable, and a better solution exists.</p> <h2 id=a-better-stab-maps >A better stab – Maps</h2> <p>Rather than store empty <span class="math inline"><em>m</em></span> values, we can sparsely store <span class="math inline"><em>m</em></span> values with content by utilizing the built-in <code>Map</code> object in ECMAScript 6 – Now, we can store the <span class="math inline"><em>m</em></span> values with the <span class="math inline"><em>i</em><sub><em>p</em></sub></span> index as its key:</p> <p><span class="math display"><em>i</em><sub><em>p</em></sub> → <em>m</em></span></p> <p>This causes for a great deal of efficiency where <span class="math inline"><em>x</em></span> values are relatively near to each other – particularly, that the average difference between <span class="math inline"><em>x</em></span> values are below <span class="math inline"><em>n</em></span>, as they’ll (likely) be stored in the same <span class="math inline"><em>m</em></span> value.</p> <h1 id=implementation >Implementation</h1> <p>The code lives <a href="https://github.com/athanclark/intset.js">in my personal GitHub</a>, and can be inspected very easily - it’s only a few hundred lines.</p> <p>I tried to be thorough with the tests and benchmarks, however the latter are a bit difficult to parse. Howeverm, I am confident with the default settings of <code>IntSet</code>, but if you’d like to customize <span class="math inline"><em>n</em></span>, it can be supplied as an argument to <code>new IntSet(n)</code>.</p> <h2 id=tests >Tests</h2> <p>The tests are built using <a href="https://medium.com/criteo-engineering/introduction-to-property-based-testing-f5236229d237">property-based testing</a> techniques, namely via a <a href="https://en.wikipedia.org/wiki/Fuzzing">fuzz tester</a> library for JavaScript called <a href="https://fast-check.dev/">fast-check</a>. The following <a href="https://en.wikipedia.org/wiki/Invariant_(mathematics)">invariants</a> are tested:</p> <table> <colgroup> <col style="width: 24%" /> <col style="width: 76%" /> <thead> <tr class=header > <th style="text-align: center;">Name <th style="text-align: center;">Expression <tr class=odd > <td style="text-align: center;">Existence <td style="text-align: center;"><span class="math inline">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>x</em> : ℕ. <em>X</em>⌈<em>x</em>⌉<sub><em>x</em></sub> = <em>t</em><em>r</em><em>u</em><em>e</em></span> <tr class=even > <td style="text-align: center;">Non-Existence <td style="text-align: center;"><span class="math inline">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>x</em> : ℕ. <em>X</em>⌊<em>x</em>⌋<sub><em>x</em></sub> = <em>f</em><em>a</em><em>l</em><em>s</em><em>e</em></span> <tr class=odd > <td style="text-align: center;">Union Commutativivty <td style="text-align: center;"><span class="math inline">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>Y</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>. <em>X</em> ∪ <em>Y</em> = <em>Y</em> ∪ <em>X</em></span> <tr class=even > <td style="text-align: center;">Union Identity <td style="text-align: center;"><span class="math inline">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>. ∅ ∪ <em>X</em> = <em>X</em></span> <tr class=odd > <td style="text-align: center;">Union Associativity <td style="text-align: center;"><span class="math display">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>Y</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>Z</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>.</span> <span class="math display">(<em>X</em>∪<em>Y</em>) ∪ <em>Z</em> = <em>X</em> ∪ (<em>Y</em>∪<em>Z</em>)</span> <tr class=even > <td style="text-align: center;">Intersection Commutativivty <td style="text-align: center;"><span class="math inline">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>Y</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>. <em>X</em> ∩ <em>Y</em> = <em>Y</em> ∩ <em>X</em></span> <tr class=odd > <td style="text-align: center;">Intersection Absorption <td style="text-align: center;"><span class="math inline">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>. <em>X</em> ∩ <em>X</em> = ∅</span> <tr class=even > <td style="text-align: center;">Intersection Associativity <td style="text-align: center;"><span class="math display">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>Y</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>Z</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>.</span> <span class="math display">(<em>X</em>∩<em>Y</em>) ∩ <em>Z</em> = <em>X</em> ∩ (<em>Y</em>∩<em>Z</em>)</span> <tr class=odd > <td style="text-align: center;">Symmetric Difference Commutativivty <td style="text-align: center;"><span class="math inline">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>Y</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>. <em>X</em> ⊕ <em>Y</em> = <em>Y</em> ⊕ <em>X</em></span> <tr class=even > <td style="text-align: center;">Symmetric Difference Identity <td style="text-align: center;"><span class="math inline">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>. ∅ ⊕ <em>X</em> = <em>X</em></span> <tr class=odd > <td style="text-align: center;">Symmetric Difference Absorption <td style="text-align: center;"><span class="math inline">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>. <em>X</em> ⊕ <em>X</em> = ∅</span> <tr class=even > <td style="text-align: center;">Symmetric Difference Associativity <td style="text-align: center;"><span class="math display">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>Y</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>Z</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>.</span> <span class="math display">(<em>X</em>⊕<em>Y</em>) ⊕ <em>Z</em> = <em>X</em> ⊕ (<em>Y</em>⊕<em>Z</em>)</span> <tr class=odd > <td style="text-align: center;">Difference Identity <td style="text-align: center;"><span class="math inline">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>. <em>X</em> ∖ ∅ = <em>X</em></span> <tr class=even > <td style="text-align: center;">Difference Absorption <td style="text-align: center;"><span class="math inline">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>. <em>X</em> ∖ <em>X</em> = ∅</span> <tr class=odd > <td style="text-align: center;">Difference / Union Intersection Equivalence <td style="text-align: center;"><span class="math inline">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>Y</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>. <em>X</em> ∖ <em>Y</em> = <em>Y</em> ⊕ <em>X</em></span> <tr class=even > <td style="text-align: center;">Difference / Union Symmetric Difference Equivalence <td style="text-align: center;"><span class="math display">∀ <em>X</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>, <em>Y</em> : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em>.</span> <span class="math display"><em>X</em> ∪ (<em>X</em>⊕<em>Y</em>) = <em>X</em> ∖ <em>Y</em></span> </table> <p>I’ve deemed this to be a pretty thorough test suite. If you feel like more properties should be represented in the test suite, please feel free to <a href="https://github.com/athanclark/intset.js/issues">file a bug report</a>.</p> <blockquote> <p><strong>Note</strong>: The element-wise functions are:</p> <table> <thead> <tr class=header > <th style="text-align: center;">Name <th style="text-align: center;">Symbol <tr class=odd > <td style="text-align: center;">Insert <td style="text-align: center;"><span class="math inline"><em>X</em>⌈<em>x</em>⌉</span> <tr class=even > <td style="text-align: center;">Remove <td style="text-align: center;"><span class="math inline"><em>X</em>⌊<em>x</em>⌋</span> <tr class=odd > <td style="text-align: center;">Contains <td style="text-align: center;"><span class="math inline"><em>X</em><sub><em>x</em></sub></span> </table> <p>And, the empty set is defined as</p> <p><span class="math display">∅ : <em>I</em><em>n</em><em>t</em><em>S</em><em>e</em><em>t</em></span></p> <p>Where <span class="math inline">∅.<em>i</em><em>s</em><em>E</em><em>m</em><em>p</em><em>t</em><em>y</em>() = <em>t</em><em>r</em><em>u</em><em>e</em></span>.</p> </blockquote> <h2 id=benchmarks >Benchmarks</h2> <p>The benchmark suite is, in my opinion, sub-standard. I originally built it to try and find a good default value for <span class="math inline"><em>n</em></span>; my assumption was that <span class="math inline">64</span> would be a good value, but I wanted to verify.</p> <p>I have two forms of benchmarking suites - the first uses <a href="https://benchmarkjs.com/">Benchmark.js</a> to find a “fastest” version of the <code>union</code> function, and the second takes a heap snapshot of the <code>union</code> function of the same two sets, and also measures the approximate total amount of data stored in that resulting set. The data being generated are two sets, each of which are filled with <span class="math inline">2<sup>16</sup></span> random <code>bigint</code>s, with maximum value <span class="math inline"><em>y</em></span> of <span class="math inline">2<sup>8</sup> ≤ <em>y</em> ≤ 2<sup>32</sup></span>, and implementations of <span class="math inline"><em>n</em></span> varying between <span class="math inline">2<sup>5</sup> ≤ <em>n</em> ≤ 2<sup>15</sup></span>. The following figures show the results:</p> <div id=ops-per-sec  class=figure > </div> <div id=heap-used  class=figure > </div> <div id=total-size  class=figure > </div> <h3 id=interpretations >Interpretations</h3> <p>A few observations can be made by these figures. First, let’s start with <a href="#ops-per-sec">Operations Per Second</a>:</p> <ul> <li>Sets maximize speed for random numbers generated up to <span class="math inline">2<sup>8</sup></span> when <span class="math inline"><em>n</em> ≥ 2<sup>8</sup></span>. <li>Sets maximize speed for random numbers generated up to <span class="math inline">2<sup>12</sup></span> when <span class="math inline"><em>n</em> ≥ 2<sup>12</sup></span>. <li>Before the speed is maximized, the approach to obtaining higher speed at a particular max random value comes at a curve. <li>The entire space past <span class="math inline">2<sup>20</sup></span> for maximum size is pretty flat - no drastic speed increases. </ul> <p>Secondly, <a href="#heap-used">Heap Used</a>:</p> <ul> <li>The dominating factor is the maximum value of the generated numbers, not <span class="math inline"><em>n</em></span>. <li><span class="math inline"><em>n</em></span>’s increase does have a minor factor past <span class="math inline"><em>n</em> ≥ 2<sup>12</sup></span>, especially in the extreme cases of <span class="math inline"><em>y</em> = 32</span>. </ul> <p>Lastly, <a href="#total-size">Total Size</a>:</p> <ul> <li>Total size appears to gain exponential growth past <span class="math inline"><em>y</em> ≥ 24</span>, and can be directly observed with an increase in <span class="math inline"><em>n</em></span>. </ul> <p>Unfortunately, the last figure doesn’t give us a great deal of insight to the (potential) total amount of memory used, but rather a philosophical perspective, which is why I included the “Heap Used” figure as well.</p> <p>Given that concern, I’ve opted to reduce the chart’s ranges a bit for these next figures - <span class="math inline"><em>n</em></span> will not exceed <span class="math inline">2<sup>12</sup></span>, and the max number generated will not exceed <span class="math inline">2<sup>24</sup></span>.</p> <div id=reduced-ops-per-sec  class=figure > </div> <div id=reduced-heap-used  class=figure > </div> <div id=reduced-total-size  class=figure > </div> <h3 id=further-interpretations >Further Interpretations</h3> <p>From the latter two figures, a reasonable conclusion can be observed – space consumed by sets are relatively constant up until the maximum number generated becomes greater than <span class="math inline">2<sup>16</sup></span>. This, however, may be indirectly related to the fact that there are only <span class="math inline">2<sup>16</sup></span> numbers in each set; smaller generated values would likely exhaust the sample space.</p> <p>Additionally, although the assumed spatial consumtion of the sets (last figure) is assumed to increase as <span class="math inline"><em>n</em></span> increases, we can see that for cases where the maximum generated number is greater than <span class="math inline">2<sup>16</sup></span>, the heap is actually larger for smaller values of <span class="math inline"><em>n</em></span>. I assume this to be due to the operational overhead, i.e. callbacks and the like, because of the need to “mesh” more values together.</p> <h1 id=conclusion >Conclusion</h1> <p>There are a few key points to receive from this investigation:</p> <ol type=1 > <li>Potential gains from this library are drastically diminished when the set contents can be larger than <span class="math inline">2<sup>16</sup></span>, both in terms of speed and space. <li>For values generated up to <span class="math inline">2<sup>12</sup></span>, I recommend a default <span class="math inline"><em>n</em></span> value of <span class="math inline">2<sup>8</sup></span>, due to the clef in the <a href="#reduced-ops-per-sec">Reduced Operations Per Second</a> at <span class="math inline"><em>x</em> = 8, <em>y</em> = 12</span>. <li>For values generated up to <span class="math inline">2<sup>16</sup></span>, I recommend an <span class="math inline"><em>n</em></span> value of <span class="math inline">2<sup>12</sup></span>. $. For larger values, maybe consider a different library. </ol> <h2 id=considerations >Considerations</h2> <p>A few potential deficiencies should also be identified:</p> <ul> <li>I only benchmarked <code>union</code>, not the other set-wise operations. <li>I only benchmarked sets that have <span class="math inline">2<sup>16</sup></span> elements, not fewer ones. <li>I used <code>Math.random()</code> to generate the random numbers – there may be a lack of uniformity in the random numbers being generated. </ul> <p>However, I don’t want to address those at this time. I hope you enjoyed this exploration! It was very insightful for me.</p> </article> </section> <footer> Copyright &copy; Athan Clark 2023, All Rights Reserved </footer> </main>